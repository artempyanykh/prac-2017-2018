# Задание 1

## *Краткое описание задания*

1) *(50 баллов)* Необходимо написать функция ```nash_equilibrium(a)```, которая принимает матрицу выигрыша и возвращает значение игры и оптимальные стратегии первого и второго игроков.

2) *(50 баллов)* Проиллюстрировать работу вашего кода путем решения нескольких игр и визуализации спектров оптимальных стратегий игроков в Jupyter. В частности, нужно привести игры, в которых:
	* Cпектр оптимальной стратегии состоит из одной точки (т.е. существует равновесие Нэша в чистых стратегиях),
	* Cпектр оптимальной стратегии неполон (т.е. некоторые чистые стратегии не используются),
	* Cпектр оптимальной стратегии полон.
	
3) *(10 баллов)* Оформить решение в виде пакета.

4) *(20 баллов)* Написать unit-тесты для функции ```nash_equilibrium```.

## *Подход к Решению*

### *Основные моменты*
1. Написание функции ```nash_equilibrium(in_matrix)``` , которая:
>1) Принимает в качестве входных данных матрицу выигрыша для некоторой антагонистической матричной игры.
>2) Сводит задачу поиска оптимальных стратегий игроков и значения игры к двойственной задачи линейного программирования.
>3) Решает двойственную задачу линейного программирования при помощи симплекс-метода.
>4) По решениям двойственной задачи линейного программирования находит оптимальные стратегии игроков, а так же значение игры.
		
2. Написание части, реализующей визуализацию спектров оптимальных стратегий игроков в Jupyter
>1) Необходимо использовать объекты и методы из библиотеки ```matplotlib.pyplot```.
>2) Необходимо подобрать несколько матриц выигрыша, которые наиболее полно охватили бы различные варианты матричных антагонистических игр. 
	
3. Создание программного пакета.
>1) Необходимо структурировать решение для его представление в виде python пакета.

### *Аналитические пояснения*
В качестве входных данных имеем антагонистическую игру, заданную матрицей выигрыша _А=(aij)_ размера _n_ на _m_, для которой необходимо найти цену игры и оптимальные стратегии игроков.

Прежде чем применять стандартный подход: сведение исходной задачи к двойственной задаче линейного программирования, необходимо проверить: не содержит ли матрица седловой точки, тогда задача разрешена в чистых стратегиях (существует равновесие Нэша). 

Если _aij_ - седловая точка матрицы _А_ (_aij_ - минимальный элемент в строке _i_ и максимальный элемент в строке _j_), то цена игры равна _aij_, и первый игрок выбирает стратегию _i_, а второй игрок стратегию _j_.

Если матрица игры _A_ не имеет седловой точки, то исходная задача сводится к двойственной задаче линейного программирования. В рамках данного Readme не будут приводиться математические выкладки, а лишь будут объяснены основные моменты:

1. Для первого игрока: 

>1) Производится замена переменных: вероятность выбора _i-ой_ стратегии - _pi_ заменяется на _yi = pi / V_, где _V_ - это цена игры.

>2) В качестве целевой функции выбирается сумма _yi_, и необоходимо минимизировать значение целевой функции. 

>3) По матрице игры строится матрица коэффициентов задачи линейного программирования.

>4) Задача линейного программирования решается симплекс-методом.

>5) Значение игры находится как обратное значение к оптимизируемой функции.

>6) Исходя из _yi = pi / V_ находятся _pi_, так как _V_ уже известно.
2. Для второго игрока:

>1) Производится замена переменных: вероятность выбора _i-ой_ стратегии - _qi_ заменяется на _xi = qi / V_, где _V_ - это цена игры.

>2) В качестве целевой функции выбирается сумма _xi_, и необоходимо максимизировать значение целевой функции. 

>3) По матрице игры строится матрица коэффициентов задачи линейного программирования.

>4) Задача линейного программирования решается симплекс-методом.

>5) Исходя из _xi = qi / V_ находятся _xi_, так как _V_ уже известно.

## *Инструкции по запуску*

Решение задания реализовано в виде пакета, который находится в папке ```submissions/task1/mareev-meledin/package```

Для установки пакета в командной строке выполнить команду ```pip install task1_mareev_meledin```

Для использования просто сделай:
	
	Python
	import task1_mareev_meledin as ts
	print(ts.nash_equilibrium([[1, 2], [2, 3]]))
	
Cell -> Run All  - для Jupiter	
	

## *Описание файлов*
Данный пакет содержит следующие файлы: 
* Папка Jupyter - содержит файл Task1.ipynb, который содержит функцию nash_equlibrium(in_matrix), функцию res_show() и unit-тесты. 
* Папка Solve содержит пакет
	* README.rst - README к пакету
	* MANIFEST.in необходим для включения в пакет файлов с не питоновским расширением.
	* setup.py необходим для установки пакета.
	* Папка ```task1_mareev_meledin``` содержит:
		```
		1) Файл __init__.py,содержащий nash_equilibrium(in_matrix) из solve.py
		2) solve.py 
		```
			
## Необходимое ПО
### Библиотеки:
* Для ```nash_equilibrium(a)```
	* Numpy
		> Для удобной и эффективной работы с матрицами
	* Scipy 
		> Для использования методов линейного програмирования
* Для ```Task1.ipynb```
	* Fractions
		> Для корректного вывода ответа
	* Matplotlib
		> Для визуализации решений
* Для четверной части задания
	* UnitTest
		> Для тестирования функций
### Используемые функции
* len(a)
	> Узнаем размер матрицы игры.
	
* a.T 
	> Транспонирование матрицы
	
* np.min(a, 1)
	> Находим минимальный элемент для каждой строки.
	
* np.zeros(n)
	> Создаем вектор из n нулей.
	
* min(0, np.min(a))
	> Это выражение аналогично if (np.min(a) < 0) sub = np.min(a) else sub = 0
	
* np.ones(n)
	> Создаем вектор из n единиц.
	
* np.vstack((-a.T, -np.identity(n)))
	> Создание единичной матрицы np.identity
	```
	Создаем матрицу (если n равно 3):
		 -a[0, 0] -a[1, 0] -a[2, 0]
		 -a[0, 1] -a[1, 1] -a[2, 1]
		 -a[0, 2] -a[1, 2] -a[2, 2]
		       -1        0        0
		        0       -1        0
		        0        0       -1
	```
	
* np.hstack((np.full(n, -1), np.zeros(n)))
	> np.full создание массива длинны n, заполнение -1 ми
	```
	Создаем вектор (если n равно 3):
	 -1 -1 -1 0 0 0 
	```
* nnp.testing.assert_array_almost_equal(x, y, decimal=6, err_msg='', verbose=True)
	> Функция позволяет установить равенство **(но это не точно)** множеств , с точностью < 1.5 * 10^(-decimal)
		
### Программы:
1) Python 3.6
2) Jupyter Notebook 

## Работу выполнили:
**Меледин Станислав 312 группа** - [kvtvrvn](https://github.com/kvtvrvn)
* Функция res.show() в Jupyter
* Визуализация спектров оптимальных стратегий
* Тестирование с помощью unit - тестов
* Подбор тестов для отладки программы 

**Мареев Глеб 312 группа** - [GlebOlegovich](https://github.com/GlebOlegovich)
* solve.py ( функция nash_equilibrium() )
* Улучшение визуализации спектров оптимальных стратегий игроков в Jupyter
* Подбор примеров в соответствии с требованиями задания 
* Создадие пакета
	> [task1_mareev_meledin 5.1](https://pypi.python.org/pypi?:action=display&name=task1_mareev_meledin&version=5.1) - Ссылка на пакет
* Устал писать README.md 🤠


## **Cпасибо,что прочли README, терерь вы понимаете на сколько ЭТО хрупкий механизм😂**
![](https://github.com/GlebOlegovich/Smthng/blob/master/uw4vmh_298x381.jpg)
 			
