 Задание 1
===============
Краткое описание задачи
----------------
Задание состоит в численном решении антагонистической матричной игры. 

1. Необходимо написать функцию nash_equilibrium(a), которая принимает матрицу выигрыша и возвращает значение игры и оптимальные стратегии первого и второго игроков.
2. Проиллюстрировать работу кода путем решения нескольких игр и визуализации спектров оптимальных стратегий игроков в трёх случаях:
    - спектр оптимальной стратегии состоит из одной точки;
    - спектр оптимальной стратегии неполон;
    - спектр оптимальной стратегии полон.
3. Оформить решение в виде пакета.
4. Написать unit-тесты для функции nash_equilibrium.

Ход решения (идея)
----------------
Неформально игра - это модель конфликтной ситуации, в которой участвует n игроков с заданными правилами игры.
Мы рассматриваем антагонистическую игру, т.е. игру двух игроков с нулевой суммой. Игра представима в виде тройки
<X, Y, F(x,y)>, где X и Y — множества стратегий первого и второго игроков, соответственно; F(x,y) — функция выигрыша первого игрока, определенная на X * Y. Выигрыш F(x,y) первого игрока является проигрышем для второго.

*Чистая стратегия* - возможный ход игрока, выбранный с вероятностью 1. Для каждого игрока возникает вопрос увеличения выигрыша (уменьшения проигрыша). Это можно сделать применяя *смешанные стратегии* - это вероятностное распределение на множестве X для первого игрока (Y - для второго).
Говорят, что антагонистическая игра имеет решение, если F(x,y) имеет *седловую точку*. Седловая точка - это пара (x*,y*) из множества X * Y, для которой верны неравенства: F(x,y*) <= F(x*,y*) <= F(x*,y) для любых x из X, y из Y. Тогда тройка (x*,y*, v = F(x*,y*))
называется *решением игры*, а x*,y* - *оптимальными стратегиями* и v - *ценой игры*.

В нашем случае игра матричная, поэтому X={1,...,m} и Y={1,...,n}.
Антагонистическая игра может быть представлена матрицей размера n на m.
            
            a11 a12 ... a1n
      A  =  a21 a22 ... a2n
            ...
            am1 am2 ... amn
       
Цена игры пока неизвестна. Пусть она положительна v >= 0. Чтобы это выполнялось, достаточно, чтобы все элементы матрицы А были неотрицательны. Этого можно добиться прибавив одну и ту же константу M>0 (выбираем М, как модуль наименьшего элемента матрицы).
       
В этой матрице элемент aij=F(i,j). Ее строки соответсвуют стратегиям первого игрока, а столбцы - второго. Рассмотрим смешанные стратегии p=(p1,...,pm) и q=(q1,...,gn) первого и второго игроков, где компоненты этих векторов характеризуют вероятность применения чистых стратегий i и j первым и вторым игроками, соответственно (i=1,...,m; j=1,...,n). 
p1+p2+...+pm = 1
q1+q2+...+qn = 1

Найдем сначала оптимальную стратегию первого игрока. Она должны обеспечить ему выигрыш >=v при любом поведении второго игрока.
Исходя из всех утверждений выполняется система неравенств:
          
          a11 p1 + a21 p2 + ... + am1 pm  >= v
          a12 p1 + a22 p2 + ... + am2 pm  >= v
                         ... 
          a1n p1 + a2n p2 + ... + amn pm  >= v
          
Поделим все неравенства на v:

          a11 p1/v + a21 p2/v + ... + am1 pm/v  >= 1
          a12 p1/v + a22 p2/v + ... + am2 pm/v  >= 1
                         ... 
          a1n p1/v + a2n p2/v + ... + amn pm/v  >= 1

Обозначив pi/v как yi, i=1,2,...,m, получим следующую систему неравенств:

          a11 y1 + a21 y2 + ... + am1 ym  >= 1
          a12 y1 + a22 y2 + ... + am2 ym  >= 1
                         ... 
          a1n y1 + a2n y2 + ... + amn ym  >= 1
          
При этом y1+y2+...+ym = (p1+...+p2)/v = 1/v
Следовательно для первого игрока получаем ЗЛП вида:

          F(x,y*) = y1+y2+...+ym ->    min
                                   y=(y1,...,ym)

          a11 y1 + a21 y2 + ... + am1 ym  >= 1
          a12 y1 + a22 y2 + ... + am2 ym  >= 1
                         ... 
          a1n y1 + a2n y2 + ... + amn ym  >= 1
          
          yi >= 0, i=1,...,m

Аналогично получаем ЗЛП для второго игрока:

          F(x*,y) = x1+x2+...+xm ->    max
                                   x=(x1,...,xm)

          a11 x1 + a12 x2 + ... + a1n xn  <= 1
          a21 x1 + a22 x2 + ... + a2n xn  <= 1
                         ... 
          am1 x1 + am2 x2 + ... + amn xn  <= 1
          
          xi >= 0, i=1,...,m

Эти две задачи являются двойственными, поэтому нет необходимости решать обе, т.к., получая решение для одной, мы получаем решение и для второй.

Суть метода
----------------
Поиск решения антогонистической игры, заданной матрицей выигрышей mxn, сводится к поиску решения пары взаимодвойственных ЗЛП **симплекс-методом**.
Основой симплекс-метода является мнжество вершин.
Алгоритм: выбираем такую вершину, в которой целевая функция достигает максимума (минимума). По определенному правилу находится начальный опорный план (нулеве решение) на основе базиса. Далее следует проверка а оптимальность.
Если план оптимален, то задача решена. Если нет, то переходим к другой вершине.
На каждом шаге значение целевой функции будет заведомо лучше, чем в предыдущем.
Переход от одной вершины к другой основан на вычислительных действиях, которые удобно представлять в виде таблиц.
Вершин конечное число, поэтому за конечное число шагов мы приходим к оптимальному решению.

Рассморим основные этапы симплекс-метода более подробно:

* **Шаг 0. Составляем симплекс-таблицу, соответствующую исходной задаче.**

Строчек в таблице столько, сколько равенств в системе ограничений, а столбцов - столько, сколько свободных переменных. Базисные переменные заполняют первый столбец, свободные - верхнюю строку таблицы. Нижняя строка называется индексной, в ней записываются коэффициенты при переменных в целевой функции. В правом нижнем углу первоначально записывается 0, если в функции нет свободного члена; если есть, то он записывается с противоположным знаком. На этом месте (в правом нижнем углу) будет значение целевой функции, которое при переходе от одной таблицы к другой должно увеличиваться по модулю.


* **Шаг 1. Проверяем на допустимость.**

Проверяем на положительность элементы столбца свободные членов. Усли среди них нет отрицательных, то найдено допустимое решение и мы переходим к **шагу 2**. Если в столбце свободных членов имеются отрицательные элементы, то выбираем среди них максимальный по модулю - он задает ведущую строку k. В этой строке так же находим максимальный по модулю отрицательный элемент akl - он задает ведущий столбец - l и является ведущим элементом. Переменная, соответствующая ведущей строке исключается из базиса, переменная соответствующая ведущему столбцу включается в базис. 

Пересчитываем симплекс-таблицу согласно методу Жордана-Гаусса.
Если же среди свободных членов есть отрицательные элементы - а в соответствующей строке - нет,то условия задачи несовместны и *решений нет*.
Если после перерасчета в столбце свободных членов остались отрицаетельные элементы, то переходим к **шагу 1**, если таких нет, то к **шагу 2**. 


* **Шаг 2. Проверка на оптимальность.**

Если среди элементов симплексной таблицы, находщихся в нижней строке (не беря нулевое значение вектора (столбца) свободных членов - текущее значение целевой функции) нет отрицательных, то *найдено оптимальное решение*. 

Если же в нижней строке (коэффициенты при переменных в целевой функции) есть отрицательные элементы, то решение требует улучшения. Выбираем среди отрицательных элементов строки  максимальный по модулю  а0r = min {a0i} ,
где r - столбец в котором он находится будет ведущим. Для того, что бы найти ведущую строку, находим отношение соответсвующего свободного члена и элемента из ведущего столбца, при условии, что они неотрицательны.

Пересчитываем симплекс-таблицу методом Жордана—Гаусса. Если в новой таблице после перерасчета в нижней строке остались отрицательные элементы переходим к **шагу 2**. 

 Если невозможно найти ведущую строку, так как нет положительных элементов в ведущем столбце, то функция в области допустимых решений задачи не ограничена - алгоритм завершает работу.

Если в нижней строке и в столбце свободных членов все элементы положительные, то *оптимальное решение найдено*. 


Реализация решения
----------------
На вход функции nash_equilibrium() подаётся матрица m * n, где m - число стратегий первого игрока, n - второго.
Оптимальной стратегией первого игрока является вектор вероятностей, где i-му элементу соотвествует вероятность применить чистую i-ю стратегию.
Элементы матрицы соотвествуют выигрышу первого игрока и проигрышу второго при соответствующих стратегиях.

С помощью вероятностей использования чистых стратегий и соответствующих ситуациям выигрышей, записываем систему неравенств, 
максимизирующую минимальный выигрыш первого игрока при любой стратегии второго (ограничения формируются из столбцов матрицы А.). 
Для второго игрока мы минимизируем его проигрыш, т.е. выигрыш первого (ограничения формируются из строк матрицы А или из столбцов транспонированной).

Таким образом получаем пару двойственных задач линейного программирования (ЗЛП). Решаем ЗЛП с помощью функции linprog() из библиотеки scipy.
Реализуя функцию print_game(), визуализируем работу кода в виде графиков с помощью функций из библиотеки matplotlib.

Необходимое ПО
---------------
Для удобной и наглядной работы с ЯП Python можно воспользоваться интерактивной средой разработки Jupyter, 
вводя в окне терминала `jupiter notebook` и открывая нужные проекты (в частности для запуска файлов с расширением .ipynb необходимо открыть файл и выбрать в верхнем меню Cell -> Run all)


### Библиотеки
* **Numpy**
Предназначена для оперирования многомерными массивами и математическими функциями, предназначенными для работы с многомерными массивами.

* **Scipy**
Педназначена для выполнения научных и инженерных расчётов. В нашем случае необходима для функции `linprog()` из пакета `scipy.optimize`, который содержит в себе множество алгоритмов оптимизации.
Цель функции `linprog()` - минимизация линейной функции с линейными ограничениями равенства и неравенства

* **Matplotlib**
Предназначена для работы с графиками, а именно для визуализации решений ,в нашем случае, с помощью функций:
`figure(), scatter(), xlabel(), ylabel(), grid(), show()`

* **UnitTest, nosetests**
Предназначены для тестирования

**Особенности основной функции из библиотеки scipy, используемой для решения задачи - linprog()**
 В общем случае функция `linprog()`, которая решает ЗЛП, соответствующую матрице А,  имеет 8 параметров (i=0,1,...,7)
`linprog(c, A_ub, b_ub, A_eq, b_eq, bounds, method, callback, options)`

- `c` - вектор коэфф-ов целевой функции.
-` A_ub, b_ub` - матрицы с коэффициентами и векторы правой части для системы **неравенств**
- `A_eq, b_eq` - матрицы с коэффициентами и векторы правой части для системы **равенств**
- `bounds` - границы для переменных xi
- `method` - метод, используемый для решения задачи (симплекс-метод)
- `callback`- функция обратного вызова (может быть вызвана для каждой итерации симплекс-метода, например, для получения вектора решений для текущей итерации)
- `options` - опции(например, чтобы задать максимальное количество итераций)

В нашем случае для решения ЗЛП используются только первые три параметра.

**Используемые функции из библиотеки matplotlib:**
- `figure` - создает объектную область для графика
- `scatter` - создает график по меткам (точкам)
- `xlabel`, `ylabel`  - позволяют помечать координатные оси x и y
- `grid` - создает координатную сетку
- `show` - осуществляет непостредственную визуализацию полученного графика



Инструкция по установке пакета, его использованию и тестированию
----------------------

Решение задания реализовано в виде пакета Nash_equilibrium, который находится в папке 
`submissions/task1/shmatenko-agaidarova/Nash_equilibrium`

### Описание файлов

Пакет содержит файлы:

* game.ipynb - содержит функцию nash_equlibrium(), функцию print_game() и примеры для трёх различных случаев.
* MANIFEST.in - необходим для включения в пакет файлов с расширением не .py
* setup.py - необходим для установки пакета и его тестирования
* папка Nash_equilibrium

Каталог Nash_equilibrium содержит папки:
* code (nash.py c тестируемой функцией nash_equlibrium())
* tests (с файлом Test_nash.py, содержащий код тестов)

Замечание: __init__.py необходим для того, чтобы папка распознавалась как модуль.

### Установка пакета
Находясь в папке `\Nash_equilibrium` ввести команду `pip install ./`

Для запуска функции nash_equilibrium() введите команды
```
from Nash_equilibrium.code.nash import nash_equilibrium
nash_equilibrium(*your matrix*)
```
### Тестирование
Работу функции можно протестировать, введя команду `python setup.py test` из папки `\Nash_equilibrium` или команду 
`nosetests tests`, находясь в директории `\Nash_equilibrium\Nash_equilibrium`

Задание выполнили
---------------
Шматенко Дарья
* функция nash_equlibrium()
* создание пакета
* оформление тестов
* описание проекта

Агайдарова Айганым
* визуализация работы в виде графиков
* подбор примеров для матричных игр
* подбор примеров для тестирования
* описание проекта
