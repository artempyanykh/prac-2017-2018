Краткое описание задачи 
========================
Задание 1 состоит в численном решении антагонистической матричной игры.
  В рамках данного задания мы:
  - написали код, решающий матричную игру симплекс методом путем сведения ее к паре двойственных задач линейного программирования
  - проиллюстрировали работу данного кода путем визуализации спектров оптимальных стратегий
  - оформили решение в виде пакета game
  - написали автоматические тесты для нашего решения.
 
 Аналитическое решение
  -------------------------
***Матричной игрой*** называется игра двух лиц с нулевой суммой, в которой в распоряжении каждого из них имеется конечное множество стратегий. Правила матричной игры определяет платёжная матрица, элементы которой - выигрыши первого игрока, которые являются также проигрышами второго игрока.

Под ***стратегией*** понимается совокупность правил (принципов), определяющих выбор варианта действий при каждом личном ходе игрока в зависимости от сложившейся ситуации.

Если первый игрок использует чистые стратегии с вероятностями Pi (i = 1, 2, …, m), то вектор P = (P1, P2, …, Pm) называется ***смешанной стратегией первого игрока***. При этом сумма этих вероятностей равна единице.

Если второй игрок использует чистые стратегии с вероятностями Qj (j = 1, 2, …,n), то вектор Q = (Q1, Q2, ..., Qn) называется ***смешанной стратегией второго игрока***. При этом сумма этих вероятностей равна единице.

Если первый игрок использует смешанную стратегию p, а второй игрок - смешанную стратегию q, то имеет смысл ***математическое ожидание***  E(p, q) выигрыша первого игрока (проигрыша второго игрока). Чтобы его найти, нужно перемножить вектор смешанной стратегии первого игрока (который будет матрицей из одной строки), платёжную матрицу и вектор смешанной стратегии второго игрока (который будет матрицей из одного столбца). E(p,q) = p*A*q

***Оптимальной смешанной стратегией первого игрока*** называется такая смешанная стратегия p* , которая обеспечивала бы ему максимальный средний выигрыш V1.

***Оптимальной смешанной стратегией второго игрока*** называется такая смешанная стратегия q* , которая обеспечивала бы ему минимальный средний выигрыш V2.

Для того, чтобы найти оптимальные смешанные стратегии и седловую точку, то есть решить матричную игру в смешанных стратегиях, нужно свести матричную игру к задаче линейного программирования, то есть к оптимизационной задаче, и решить соответствующую задачу линейного программирования.

Для того, чтобы решить матричную игру в смешанных стратегиях, нужно составить прямую задачу линейного программирования и двойственную ей задачу. В двойственной задаче расширенная матрица, в которой хранятся коэффициенты при переменных в системе ограничений, свободные члены и коэффициенты при переменных в функции цели, транспонируется. При этом минимуму функции цели исходной задачи ставится в соответствие максимум в двойственной задаче.




Реализация решения
========================
  Функция nash_equilibrium() получает на вход платежную матрицу и возвращает оптимальные стратегии игроков и цену игры. Кратко о ее реализации: расписавая математическое ожидание выигрыша для игрока А при каждой из стратегий игрока B, мы получим систему неравенств. Задача для игрока А тем самым сведется к канонической ЗЛП. Проделав подобные операции для игрока B, мы получим двойственную ЗЛП к первой.  ЗЛП решается с помощью функции linprog(), находящейся в библиотеке scipy. Ей на вход была передана матрица с неотрицательными значениями (она была получена путем прибавления ко всем элементам матрицы модуля наименьшего числа и единицы). На выходе функции linprog() мы получили векторы оптимальных значений для модернизированной задачи. Путем обратных преобразований (вычитания модуля наименьшего элемента и единицы) мы получили векторы оптимальных стратегий для обоих игроков, а так же цену игры.  Для перевода вероятностей, полученных после отработки функции linprog(), в обыкновенные дроби использовалась функция Fraction().
  
  
  Файл spectre.ipynb содержит функцию spectre(), которая получает на вход оптимальные стратегии игроков, полученные с помощью nash_equilibrium(). Мы визуализировали оптимальные стратегии игроков в трех принципиально разных случаях. 
  
Используемые функции
-------------------------
***scipy.optimize.linprog(c, A_ub, b_ub)*** - минимизация целевой функции при заданных ограничениях

  *c - вектор целевой функции
  A_ub - матрица ограничений
  b_ub - вектор правых частей ограничений*
  
***numpy.amin(a)*** - вычисление наименьшего значение в заданном массиве

  *a - массив значений*
  
***numpy.transpose(A)*** - транспонирование заданного массива

  *A - массив значений*
  
***numpy.ones(m)*** - заполнение массива единицами

  *m - размерность заполняемого массива*
  
***numpy.sum(a)*** - вычисление суммы элементов заданного массива

  *a - массив значений*
  
***numpy.append(a)*** - добавление заданного элемента в конец массива

  *a - добавляемое значение*
  
***fractions.Fraction(a)*** - преобразование заданного значение к классу обыкновенных дробей

  *a - препобразуемое значение*
 
***len(a)*** - вычисление размерности заданного массива

  *a - массив значений*
 
***plt.figure()*** - создание фигуры для отрисовки

***fig.add_subplot(a)*** - создание и выбор прямоугольника в фигуре для отрисовки

  *a - определенное значение, которое задается тройкой m,n,k. m - кол-во строк для прямоугольников, n - кол-во столбцов, k - текущий прямоугольник*
  
***numpy.arange(a, b, c)*** - создание массива со значениями от a до b с шагом в c

  *a, b, c - числа*
  
***ax.set_xticks(a)*** - создание подписей для x-координат прямоугольника ax

  *a - массив значений*
  
***ax.set_title(str)*** - создание заголовка для прямоугольника ax

  *str - строка*

***ax.scatter(x, y)*** - поточечная отрисовка графика с координатами (xi,yi)

  *x, y - массивы значений*

***ax.set_position(x,y,w,h)*** - задание позиции для прямоугольника ax

  *x,y - координаты
  w,h - ширина и высота*
  
***ax.grid()*** - отрисовка сетки для прямоугольника ax

**plt.show()*** - отрисовка фигуры

  Необходимое ПО
  ========================
  
  Диструбутив ***Anaconda***
  
  Графическая веб-оболочка для IPython ***Jupyter notebook***
  
  Библиотеки
  -------------------------
   * Numpy (удобная работа с матрицами)
   * Scipy
   * Fractions
   * Matplotlib (для визуализации)
   * UnitTest (для тестирования)
   
 
   
  
  Инструкция по запуску
  ========================
   Установка пакета
  -------------------------
   Для установки пакета нужно выполнить команду
   
      pip install git+git://github.com/rodinis/game
     
   
   После этого можно использовать функцию ***nash_equilibrium*** из пакета с помощью
   
      import game
   или
   
      from game import nash_equilibrium
      
   Тестирование 
  -------------------------
  Для того чтобы увидеть визуализацию работы функции ***nash_equilibrium***, необходимо отркыть в Jupyter файл _spectre.ipynb_ лежащий в директории _game_. Далее выполнить Cell -> Run All и можно будет увидеть визуализацию функции nash_euqilibrium на трех различных тестах.
   
   Unit-тесты
  -------------------------
   
   Для запуска unit-тестов нужно перейти в директорию game/game и выполнить команду:
    
    nosetests tests
    
   Пакет
  -------------------------
 Создан пакет game для решения антагонистической матричной игры. Он содержит:
   1. Модуль nash_equilibrium.py, в котором реализована соответствующая функция 
   2. Файл spectre.ipynb, в котором реализована функция spectre(), позволяющая визуализировать решения задачи. Также этот файл содержит 3       примера спектров (из одной точки, неполон, полон)
   3. Файл MANIFEST.in для добавления в пакет файлов, имеющих расширение не .py
   4. Пакет tests для проверки корректности работы модуля nash_equilibrium.py (с помощью unit-тестов)
   5. Файл setup.py, в котором хранятся метаданные о пакете

    
  
  
  Важно
  ========================
  
  Папка game содержит одноименный пакет, для которого прилагается файл README.rst, описывающий структуру проекта
  
  
  Участники
   ========================
   Родин Иван - 311 группа:
   
   * Функция nash_equilibrium
   * Функция spectre
   * Оформление jupyter - файла
   
   
   Сумин Даниил - 311 группа:
   
   * Оформление решения в виде пакета
   * Реализация unit-тестов
   * Файл readme
   
  
