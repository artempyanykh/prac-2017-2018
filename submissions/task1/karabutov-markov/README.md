# Задание 1

## Краткое описание задания

1) *(50 баллов)* Необходимо написать функция ```nash_equilibrium(a)```, которая принимает матрицу выигрыша и возвращает значение игры и оптимальные стратегии первого и второго игроков.

2) *(50 баллов)* Проиллюстрировать работу вашего кода путем решения нескольких игр и визуализации спектров оптимальных стратегий игроков в Jupyter. В частности, нужно привести игры, в которых:
    1) спектр оптимальной стратегии состоит из одной точки (т.е. существует равновесие Нэша в чистых стратегиях),
    2) спектр оптимальной стратегии неполон (т.е. некоторые чистые стратегии не используются),
    3) спектр оптимальной стратегии полон.
    
3) *(10 баллов)* Оформить решение в виде пакета.

4) *(20 баллов)* Написать unit-тесты для функции ```nash_equilibrium```.

## Ход решения

1. Реализация функции ```nash_equilibrium(a)```
* Аргументы функции: матрица выигрыша и два флага
* Задача сводится к решению пары двойственных задач линейного программирования
* Решение задач находим с помощью симплекс-метода 
* Симплекс-метод позволяет получить на выходе оптимальные стратегии игроков и значение игры

2. Написание части, реализующей визуализацию спектров оптимальных стратегий игроков в Jupyter

3. Создание программного пакета

4. Тестирование функции ```nash_equilibrium(a)```

## Суть метода:

Алгоритм поиска решения матричной антагонистической игры, заданной матрицей выигрышей, имеющей размерность m×n,  сводится к алгоритму симплекс-метода решения пары взаимодвойственных задач линейного программирования.  Пусть антагонистическая игра задана матрицей выигрышей A, имеющей размерность m×n. Необходимо найти решение игры, т.е. определить оптимальные смешанные стратегии первого и второго игроков:  p*= (p1*, p2*, …, pm*), q*= (q1*, q2*,…, qn*), где P* и Q* - векторы, компоненты которых pi* и pj* характеризуют вероятности применения чистых стратегий i и j соответственно первым и вторым игроками и соответственно для них выполняются соотношения: 

p1* + p2* + … + pm* = 1, 

q1* + q2* + … + qn* = 1

Найдём сначала оптимальную стратегию первого игрока p*. Эта стратегия должна обеспечить выигрыш первому игроку не меньше V, т.е. ≥V , при любом поведении второго игрока, и выигрыш, равный V , при его оптимальном поведении, т.е. при стратегии q*.
Цена игры V нам пока неизвестна. Без ограничения общности, можно предположить её равной некоторому положительному числу V>0. Действительно, для того, чтобы выполнялось условие V > 0, достаточно, чтобы все элементы матрицы A были неотрицательными. Этого всегда можно добиться с помощью аффинных преобразований: прибавляя ко всем элементам матрицы A одну и ту же достаточно большую положительную константу М; при этом цена игры увеличится на М, а решение не изменится. 
Предположим, что первый игрок A применяет свою оптимальную стратегию p*, а второй игрок B свою чистую стратегию j-ю, тогда средний выигрыш (математическое ожидание) первого игрока A будет равен: 

aj  = aijp1* + … + amjpm*

Оптимальная стратегия первого игрока (A) обладает тем свойством, что при любом поведении второго игрока (B) обеспечивает выигрыш первому игроку, не меньший, чем цена игры V; значит, любое из чисел aj не может быть меньше V (≥ V). Следовательно, при оптимальной стратегии, должна выполняться следующая система неравенств: 

a11p1* + … + amjpm* >= V

a12p1* + … + amjpm* >= V                                                             

…                                                                      

a1np1* + … + amnpm*>= V

(1)

Разделим неравенства (1) на положительную величину V (правые части системы) и введём обозначения y1, …, ym для новых переменных p*1/V, …, p*m/V,  y1 ≥ 0, y2 ≥ 0, .., ym ≥ 0. (2)
Тогда условия запишутся в виде: 

a11y1 + … + amjym >= 1

a12y1 + … + amjym >= 1                                                                 

…                   

a1ny1 + … + amnym >= 1 

(3)

где y1, y2, ..., ym - неотрицательные переменные. В силу (2) переменные y1, y2 , ..., ym удовлетворяют условию, которое обозначим через F: 

F = y1 + y2 + … + ym = 1/V.

Поскольку первый игрок свой гарантированный выигрыш (V) старается сделать максимально возможным (V → max) , очевидно, при этом правая часть – 1/V → min - принимает минимальное значение. Таким образом, задача решения антагонистической игры для первого игрока свелась к следующей математической задаче:
определить неотрицательные значения переменных y1, y2, ..., ym, чтобы они удовлетворяли системе функциональных линейных ограничений в виде неравенств (3), системе общих ограничений (2) и минимизировали целевую функцию F:

F = y1 + y2 + ... + ym → min
 
 Это задача линейного программирования (двойственная) и она может быть решена симплекс-методом. Таким образом, решая задачу линейного программирования, можно найти оптимальную стратегию p*= (p1*, p2*, …, pm*) игрока A. 
Чтобы найти оптимальную стратегию q*= (q1*, q2*,…, qn*) игрока B, нужно провести аналогичные действия, с той разницей, что игрок B стремится не максимизировать, а минимизировать выигрыш (по сути - проигрыш), а значит, не минимизировать, а максимизировать величину 1/V, т.к. V → min. Вместо условий (3) должны выполняться условия: 

a11x1 + … + amjxm <= 1

a12x1 + … + amjxm <=1                                                                 

…                                                                      

a1nx1 + … + amnxm <= 1    

(4)

где x1 = q*1/V, …, xm = q*m/V, 

x1 ≥ 0, x2 ≥ 0, .., xn ≥ 0. (5)

Требуется так выбрать переменные x1, x2, .., xn, чтобы они удовлетворяли условиям (4), (5) и обращали в максимум линейную функцию цели F': 

F’ = x1 + x2 + … + xm = 1/V → max

Таким образом, задача решения антагонистической игры для второго игрока свелась к следующей математической задаче: 
определить неотрицательные значения переменных x1, x2, .., xn, чтобы они удовлетворяли системе функциональных линейных ограничений в виде неравенств (4), системе общих ограничений (5) и максимизировать целевую функцию F':

F' = x1 + x2 + .. + xn → max 
 
Это типичная задача линейного программирования (прямая) и она может быть решена симплекс-методом. Таким образом, решая прямую задачу линейного программирования, мы можем найти оптимальную стратегию Q*= (q1*, q2*,…, qn*) игрока B.

**Алгоритм симплекс-метода** заключается в том, что из множества вершин, принадлежащих границе множества решений системы неравенств, выбрается такая вершина, в которой значение целевой функции достигает максимума (минимума). По определенному правилу находится первоначальный опорный план (некоторая вершина области ограничений). Проверяется, является ли план оптимальным. Если да, то задача решена. Если нет, то переходим к другому улучшенному плану - к другой вершине. Значение целевой функции на этом плане (в этой вершине) заведомо лучше, чем в предыдущей. Алгоритм перехода осуществляется с помощью некоторого вычислительного шага, который удобно записывать в виде таблиц, называемых симплекс-таблицами. Так как вершин конечное число, то за конечное число шагов мы приходим к оптимальному решению.

**Этапы метода:**

**I этап:** Переход к канонической форме задачи линейного программирования путем введения неотрицательных дополнительных балансовых (базисных) переменных. Запись задачи в симплекс-таблицу. Между системой ограничений задачи и симплекс-таблицей взаимно-однозначное соответствие. Строчек в таблице столько, сколько равенств в системе ограничений, а столбцов - столько, сколько свободных переменных. Базисные переменные заполняют первый столбец, свободные - верхнюю строку таблицы. Нижняя строка называется индексной, в ней записываются коэффициенты при переменных в целевой функции. В правом нижнем углу первоначально записывается 0, если в функции нет свободного члена; если есть, то он записывается с противоположным знаком. На этом месте (в правом нижнем углу) будет значение целевой функции, которое при переходе от одной таблицы к другой должно увеличиваться по модулю.  

**II этап:** Проверка опорного плана на оптимальность. Для этого необходимо анализировать строку целевой функции F. Если найдется хотя бы один коэффициент индексной строки меньше нуля, то план не оптимальный, и его необходимо улучшить.
III этап. Улучшение опорного плана. Из отрицательных коэффициентов индексной строки выбирается наибольший по абсолютной величине. Затем элементы столбца свободных членов симплексной таблицы делит на элементы того же знака ведущего столбца. Далее идет построение нового опорного плана. Переход к новому опорному плану осуществляется в результате пересчета симплексной таблицы методом Жордана—Гаусса.

**IV этап:** Выписывание оптимального решения.



## Инструкции по запуску

```./proj.py``` - для первой части

```Cell -> Run All```  - для Jupiter

Для установки пакета на компьютер: 
* скачать архив 

* разархивировать его

* находясь в папке с файлом setup.py дать компьюютеру команду ```pip3 install .```

## Необходимое ПО

### Библиотеки :
1) **Numpy**

* Для работы с матрицами

———

* Использованные в проекте функции из библиотеки Numpy:

. numpy.array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0) - создает массив

. numpy.arange([start, ]stop, [step, ]dtype=None) - список из последовательности чисел

. numpy.empty(shape, dtype=float, order='C') - создает массив без его заполнения

. numpy.loadtxt(fname, dtype=<type 'float'>, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0)[source] - для загрузки данных из файла

. numpy.ones(shape, dtype=None, order='C') - массив из единиц

. numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)

2) **Matplotlib**

* Для построения графиков

———

. matplotlib.pyplot.title(s, *args, \**kwargs) - Set a title of the current axes.

. matplotlib.pyplot.grid(b=None, which='major', axis='both', **kwargs) - Turn the axes grids on or off.

. matplotlib.pyplot.plot(*args, **kwargs) - Plot lines and/or markers to the Axes. args is a variable length argument, allowing for multiple x, y pairs with an optional format string. For example, each of the following is legal.

. matplotlib.pyplot.show(*args, **kw) - Display a figure. When running in ipython with its pylab mode, display all figures and return to the ipython prompt.



3) **Scipy** 

* Для использования методов линейного програмирования

———

Функция `linprog` из библиотеки `SciPy` необходима для решения двойственной задачи линейного программирования с помощью симплекс-метода. 


. scipy.optimize.linprog(c, A_ub=None, b_ub=None, A_eq=None, b_eq=None, bounds=None, method='simplex', callback=None, options=None)`

Она решает следующую задачу линейного программирования c матрицей A: 

Минимизировать: 

F = c^T * x, 

Для системы уравнений  

A_ub * x <= b_ub

A_eq * x == b_eq 


4) **UnitTest**

* Для тестирования функций

### Программы:

1) Python 3
2) Jupyter Notebook

## Участники

1) Карабутов Дмитрий - 312 гр.
> Реализация функции ```nash_equilibrium(a)```

> Unit тесты

> Тестирование функции ```nash_equilibrium(a)```

2) Марков Игорь - 312 гр. 
> Реализация спектров оптимальных стратегий

> Сделал первое дополнительное задание, включающее оформление задания в виде пакета

> Отчеты в Jupiter и README.md

