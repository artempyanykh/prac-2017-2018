Задание prac-io-1. v.1.3
---------------

# Краткое описание задания

Задание 1 заключается в:
1. Написании программы на языке программирования Python, которая должна:

    - По заданной матрице решать антагонистическую матричную игру: находить оптимальные стратегии для обоих игроков и цену игры
    - Визуализировать полученные в процессе решения данные

2. Демонстрации работы кода с помощью примеров.

# Используемая версия Python 
Python 3.6.1
# Файлы проекта
- **task1.ipynb** --- код + примеры
- **linear_prog.pdf** --- обоснование сведения матричной игры к двум задачам линейного программирования(далее -- ЗЛП)
- **simplex.pdf** --- обоснование работы симплекс-метода решения ЗЛП
- **README.md** --- описание проекта

# Реализация


- Написана функция **nash_equilibrium(A)**, решающая матричную антагонистическую игру (то есть игры двух лиц, выигрыши которых противоположны) путём сведения её к двум ЗЛП и последующего применения симплекс-метода. Считается, что игра приведена к матричной форме и на вход функции подаётся числовая матрица произвольного размера. Алгоритм получения ЗЛП подробно описан в файле **linear_prog.pdf** и реализован в функции. Для решения ЗЛП симплекс-методом использована функция *linprog* из пакета *optimize* библиотеки *linprog*. Симплекс-метод для канонической ЗЛП описан в файле **simplex.pdf**. Функция возвращает объект типа *tuple*(кортеж), содержащий цену игры и оптимальные стратегии игроков.

- Написана функция **visualize(opt_strat1, opt_strat2)**, строящая диаграммы, соответсвующие оптимальным стратегиям игроков. На вход функции подаётся два аргумента, оптимальные стратегии двух игроков, предполагаемо полученные в функции *nash_equilibrium*. Полученные данные затем визуализируются в виде диаграмм. Для построения диаграммы использовалась библиотека *matplotlib*. Реализован вариант столбчатой диаграммы.

- Приведены примеры матричных игр, в которых спектр оптимальной стратегии:
  - Состоит из 1 точки (существует равновесие Нэша в чистых стратегиях);
  - Неполон(игроки не используют свои некоторые стратегии);
  - Полон. 


# Используемые библиотеки
- **numpy**, для работы с многомерными массивами (*ndarray*)
  - numpy.ndarray.min(axis=None, out=None, keepdims=False) – возвращает минимум многомерного массива по заданным осям

  - numpy.ndarray.transpose(a,axes=None) – поворачивает задаваемый многомерный массив вокруг заданных осей

  - numpy.ndarray.ones(shape, dtype=None, order=’C’) – создает новый многомерный массив заданного размера и типа, заполненный единицами

  - numpy.ndarray.sum(a, axis=None, dtype=None, out=None, keepdims=<class numpy._globals._NoValue>) – сумма элементов многомерного массива по заданным осям 
- **scipy**, для решения ЗЛП симплекс-методом:
  - scipy.optimize.linprog(c, A_ub=None, b_ub=None, A_eq=None, b_eq=None, bounds, method=’simplex’, callback=None, options=None) – решает задачу вида <c,x> -> min при заданных ограничениях A*x<=b 
- **matplotlib**, для построения диаграммы:
  - matplotlib.pyplot.bar(x, height, width, bottom, align) - рисует стобцы диаграммы

  - matplotlib.pyplot.figure(figsize=None, dpi=None, facecolor=None, edgecolor=None, linewidth=0.0, frameon=None, subplotpars=None, tight_layout=None) - создаёт новую фигуру

  - matplotlib.pyplot.grid(b=None, which=’major’, axis=’both’, **kwargs) – добавляет оси сетки

  - matplotlib.pyplot.axes(fig, rect, facecolor=None, frameon=True, sharex=None, sharey=None, label='', xscale=None, yscale=None, axisbg=None, **kwargs) - добавляет оси

  - matplotlib.pyplot.xlabel(s, *args, **kw) – записывает строку s на оси х

  - matplotlib.pyplot.ylabel(s, *args, **kw) - записывает строку s на оси y

  - matplotlib.pyplot.title(s, *args, **kw) – записывает строку s в оглавлении

  - matplotlib.pyplot.xticks(*args, **kw) – приписываем разбиению на оси х необходимые значения

  - matplotlib.pyplot.show(*args, **kw) – выводит на дисплей все рисунки 
# Инструкции по запуску

## Необходимое ПО
- Anaconda 3 - дистрибутив ЯП Python, содержащий всё необходимое, в том числе:
  - Jupyter
  - Python 3.6

## Запуск(из окна терминала)
Из директории проекта:
```
jupyter-notebook task1.ipynb
```
В jupyter:
``` 
Cell > Run All
```

# Задание выполнили
Осипа Андрей, 311 гр.:
- функция **nash_equilibrium**: полный алгоритм решения
- функция **visualize**
- отчёт по используемым методам решения: **linear_prog.pdf**, **simplex.pdf** (исп. LaTeX)
- подготовка отчётности (**README.md**)

Абдыкалик Чингиз, 311 гр.:
- функция **nash_equilibrium**: реализация
- примеры игр
- тестирование программы
- исправление ошибок, оптимизация некоторых частей программы
- (в разработке) оформление решения в виде пакета, написание unit-тестов
