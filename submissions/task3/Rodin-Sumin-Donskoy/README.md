# Задача

Получить данные в CSV-файлах для компании Applepen, продающей яблоки и карандаши.
Требуемые данные:
- Состояние склада на каждый день
- Месячные данные о количестве сворованного товара
- Агрегированные данные об объемах продаж и количестве сворованной продукции по штату и году

# Подход к решению

- Состояние склада на каждый день
С помощью файлов sell найдем количество проданных яблок и ручек за каждый день. Далее используем данные о закупках (файл supply) 
и будем вычитать проданное количество яблок и ручек в каждый день.

- Месячные данные о количестве сворованного товара
В файле inv содержится информация о количестве товаров после учета в конце месяца. Значит, мы можем взять файл с закупками, 
вычесть из закупок за месяц проданный товар за месяц (из таблицы 1). 
Разница между полученными результатами и данными после учета inv как раз и будет равна количеству сворованного за месяц товара

- Агрегированные данные об объемах продаж и количестве сворованной продукции по штату и году
Сложим все полученные в 1) и 2) данные для каждого магазина из одного штата и объединим по году

# Реализация решения

Структура входных файлов:
  Штат - магазин - `supply/inventory/sell -.csv`
Реализована функция processing, которая в качетве аргументов принимает штат и магазин. Таким образом, вызвав 
processing(state,shop) создадутся 2 файла:
- `task1-state-shop.csv`
- `task2-state-shop.csv`

Эти файлы будут соответсвенно решением 1 и 2 задания для конкретного магазина. Кроме того, создастся глобальная таблица `task3`, 
к которой после каждого вызова функции `processing()` будут добавляться агрегированные данные по штатам и годам. 
Таким образом, вызвав функцию `processing()` для всех имеющихся магазинов, мы будем иметь таблицу task3, которая будет 
решением 3 задания (в конце она распечатывается).

Реализация `processing(state,shop)`: 

Необходимо было найти колчество проданных ручек и яблок за каждый день. Для этого воспользуемся файлом `sell`.
Обратим внимание на структуру столбца sku_num: штат-магазин-ap/pe-id транзакции
Чтобы понять продажа яблока или ручки произошла, мы использовали функцию `find` для поиска подстроки "ap" или "pe".
Затем мы к каждой транзации применили библиотечную `applymap`, чтобы у продаж появилась пометка "-1" или "5". 
"-1" означает, что было продано яблоко, а "5" - ручка. Потом мы применили `groupby['date']`, чтобы объединить все продажи
за 1 день, а затем применили `aggregate('count')`, чтобы подсчитать количество продаж за день каждого товара. Для получения
конечных таблиц сделаны преобразования, смысл которых описан в разделе **"Подход к решению"**

# Запуск

# Необходимое ПО
**Библиотеки**:
  - **pandas**
  - **matplotlib**
  - **warnings**
  - **numpy**

# Исользованные функции

- **pandas**:
  - read_csv(...) - читает CSV файл в DataFrame
  - DataFrame(data=None, index=None, columns=None, dtype=None, copy=False) - двумерная табличная структура данных с проименовынными осями(рядами и столбцами)
  - DataFrame.loc - индексатор по названию-нахождению для отбора по названию
  - DataFrame.applymap(func) - создает map для каждого ряда в DataFrame
  - DataFrame.groupby(by) группирует ряд используя "маппер" или по столбцам
  - DataFrame.aggregate(func) - агрегирует данные
  - DataFrame.fillna(value=None, method=None, axis=None, inplace=False) - заполняет неопределенные значения
  - to_datetime() - конвертирует аргумент в дату
  - to_csv(buf) - пишет DataFrame в CSV файл
  - concat(objs) - производит конкатинацию объектов

- **numpy**:
  - arange(start, stop, step) - возвращает равномерно распределенные значения на данном интервале
  - zeros(A) - заполняет нулями массив А
  - full(shape, fill_value) - возвращает новый массив заданной формы и типа, заполненный fill_value


# Участники
- Сумин Даниил
- Родин Иван
- Донской Иван
